#!/usr/bin/env python
from glob import glob
from os import chmod, close, environ, makedirs, write
from os.path import basename, expanduser, join as path_join, splitext
from pathlib import Path
from tempfile import mkdtemp, mkstemp
from typing import Any, Dict, List, Optional, cast
from urllib.parse import urljoin, urlparse
import argparse
import logging
import os
import platform
import plistlib
import re
import subprocess
import sys

from bs4 import BeautifulSoup, Tag
import requests

IS_MSYS = len(environ.get('MSYSTEM_CHOST', '')) != 0
IS_WINDOWS = IS_MSYS or os.name == "nt"
IS_MAC = bool(platform.mac_ver()[0])
IS_LINUX = not IS_MAC and not IS_WINDOWS
USER_AGENT = (
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_1) '
    'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.29 Safari/537.36')
log: Optional[logging.Logger] = None


def _setup_logging_stdout(name: Optional[str] = None,
                          verbose: bool = False) -> logging.Logger:
    name = name if name else basename(sys.argv[0])
    log = logging.getLogger(name)
    log.setLevel(logging.DEBUG if verbose else logging.INFO)
    channel = logging.StreamHandler(sys.stdout)
    channel.setFormatter(logging.Formatter('%(message)s'))
    channel.setLevel(logging.DEBUG if verbose else logging.INFO)
    log.addHandler(channel)
    return log


def _fix_msys_arg(s: str) -> str:
    return s.replace('\n', ' ').replace('\\', '\\\\') if IS_MSYS else s


class MainArgs(argparse.Namespace):
    categories: str
    chrome_command: Optional[str]
    comment: Optional[str]
    hotkey: Optional[str]
    icon: Optional[str]
    name: str
    profile_directory: str
    url: str
    verbose: bool
    window_style: int


def _chrome_command_kwargs():
    return dict(required=True) if not IS_LINUX else dict(
        default='chromium-browser')


def _cygpath_win(path: str) -> str:
    return subprocess.check_output(('cygpath', '-w', path),
                                   encoding='utf-8').strip()


def _parse_args() -> MainArgs:
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--verbose', action='store_true')
    parser.add_argument('-c', '--chrome-command', **_chrome_command_kwargs())
    parser.add_argument('-p', '--profile-directory', default='Default')
    parser.add_argument('-i', '--icon')
    if IS_LINUX:
        parser.add_argument('-C', '--categories', default='Network;')
    if not IS_MAC:
        parser.add_argument('-d', '--comment')
    if IS_WINDOWS:
        parser.add_argument('--window-style', type=int, default=1)
        parser.add_argument('--hotkey')
    parser.add_argument('name')
    parser.add_argument('url')
    return cast(MainArgs, parser.parse_args())


def _get_icon_from_site(args: MainArgs,
                        session: requests.Session) -> Optional[str]:
    global log
    assert log is not None
    if args.icon:
        return args.icon
    r = session.get(args.url)
    s = BeautifulSoup(r.content, 'lxml')
    options = ('link[rel="apple-touch-icon"]', 'link[rel="shortcut icon"]',
               'link[rel="icon"]', 'meta[name="msapplication-TileImage"]')
    tags: List[Tag] = s.select(','.join(options))
    sizes = [(0, urljoin(args.url, '/favicon.ico'))]
    log.debug('Guessed favicon URI: %s', sizes[0][1])
    for tag in tags:
        uri: Optional[str] = tag.attrs.get('href', tag.attrs.get('content'))
        if uri:
            if 'sizes' in tag.attrs:
                for w, h in map(lambda x: map(int, x.split('x')),
                                re.split(r'\s+', tag['sizes'])):
                    icon_uri = urljoin(args.url, uri)
                    log.debug('Icon with size %dx%d at URI %s', w, h, icon_uri)
                    sizes.append((w if w > h else h, icon_uri))
            else:
                icon_uri = urljoin(args.url, uri)
                log.debug('Icon without size at URI %s', icon_uri)
                sizes.append((1, urljoin(args.url, icon_uri)))
    icon = sorted(sizes, reverse=True, key=lambda x: x[0])[0][1]
    log.debug('Attempting to use icon URI %s', icon)
    if icon and session.get(icon).status_code != 200:
        return None
    return icon


def _ico_index(tmp_name: str) -> str:
    global log
    assert log is not None
    id_out = subprocess.check_output(('identify', '-format', '%w\n', tmp_name),
                                     encoding='utf-8').strip().splitlines()
    log.debug('ICO sizes available: %s', ' '.join(id_out))
    index = str(list(enumerate(sorted(id_out, reverse=True)))[0][0])
    return f'[{index}]'


def _fetch_convert_icon(icon: Optional[str], name: str, short_name: str,
                        session: requests.Session) -> Optional[str]:
    global log
    assert log is not None
    if not re.match(r'^https?\://', icon or ''):
        return icon
    assert icon is not None
    r = session.get(icon, stream=True)
    icon_prefix, icon_ext = splitext(urlparse(icon).path)
    icon_ext = icon_ext.lower()
    if IS_LINUX:
        if icon_ext in ('.png', '.xpm'):
            log.debug('Using PNG or XPM icon')
            icon = expanduser(f'~/.local/share/pixmaps/{short_name}{icon_ext}')
            with open(icon, 'wb+') as f:
                for chunk in r.iter_content(chunk_size=128):
                    f.write(chunk)
        elif icon_ext == '.svg':
            log.debug('Using SVG icon')
            icon = expanduser('~/.local/share/icons/hicolor/scalable/'
                              f'apps/{short_name}{icon_ext}')
            with open(icon, 'wb+') as f:
                for chunk in r.iter_content(chunk_size=128):
                    f.write(chunk)
        else:
            log.debug('Converting icon from %s to PNG', icon_ext[1:].upper())
            fd, tmp_name = mkstemp(suffix=icon_ext)
            icon = expanduser('~/.local/share/pixmaps/' f'{short_name}.png')
            for chunk in r.iter_content(chunk_size=128):
                write(fd, chunk)
            close(fd)
            index = ''
            if icon_ext == '.ico':
                index = _ico_index(tmp_name)
            subprocess.check_call(('convert', f'{tmp_name}{index}', icon))
            try:
                with open(icon, 'rb') as f:
                    if len(f.read()) <= 10:
                        raise FileNotFoundError()
            except FileNotFoundError:
                icon = sorted(glob(f'{icon_prefix}-*.png'), reverse=True)[0]
            os.unlink(tmp_name)
    elif IS_MAC:
        if icon_ext != '.png':
            log.debug('Converting icon from %s to PNG', icon_ext[1:].upper())
            fd, tmp_name = mkstemp(suffix=icon_ext)
            fd2, icon = mkstemp(suffix='.png')
            close(fd2)
            for chunk in r.iter_content(chunk_size=128):
                write(fd, chunk)
            close(fd)
            index = ''
            if icon_ext == '.ico':
                index = _ico_index(tmp_name)
            convert_args = ('convert', f'{tmp_name}{index}', icon)
            log.debug('Executing: %s', ' '.join(convert_args))
            subprocess.check_call(convert_args)
            try:
                with open(icon, 'rb') as f:
                    if len(f.read()) <= 10:
                        raise FileNotFoundError()
            except FileNotFoundError:
                icon_prefix = splitext(icon)[0]
                icon = sorted(glob(f'{icon_prefix}-*.png'), reverse=True)[0]
            os.unlink(tmp_name)
        else:
            fd, icon = mkstemp(suffix='.png')
            for chunk in r.iter_content(chunk_size=128):
                write(fd, chunk)
            close(fd)
    else:  # Windows
        roaming = expanduser('~/AppData/Roaming')
        prefix = f'ChromeLink{short_name}'
        if icon_ext != '.ico':
            log.debug('Converting icon from %s to ICO', icon_ext[1:].upper())
            fd, tmp_name = mkstemp(suffix=icon_ext)
            icon = path_join(roaming, f'{prefix}.ico')
            if Path(icon).exists():
                fd2, icon = mkstemp(prefix=prefix, suffix='.ico', dir=roaming)
                close(fd2)
            for chunk in r.iter_content(chunk_size=128):
                write(fd, chunk)
            close(fd)
            kwargs: Dict[str, Any] = {}
            if IS_MSYS:
                path = environ['PATH']
                kwargs['env'] = {
                    **environ,
                    **dict(PATH=f'/mingw64/bin:{path}')
                }
            subprocess.check_call(
                ('convert', _cygpath_win(tmp_name), '-define',
                 'icon:auto-resize=128,64,48,32,16', _cygpath_win(icon)),
                **kwargs)
            os.unlink(tmp_name)
        else:
            log.debug('Using ICO file')
            icon = path_join(roaming, f'{prefix}.ico')
            if Path(icon).exists():
                fd, icon = mkstemp(suffix='.ico', prefix=prefix, dir=roaming)
                for chunk in r.iter_content(chunk_size=128):
                    write(fd, chunk)
                close(fd)
            else:
                with open(icon, 'wb+') as f:
                    for chunk in r.iter_content(chunk_size=128):
                        f.write(chunk)
    return icon


def _create_desktop_file(args: MainArgs) -> None:
    # Create .desktop file
    global log
    assert log is not None
    apps_dir = expanduser('~/.local/share/applications')
    makedirs(apps_dir, exist_ok=True)
    out_name = path_join(
        apps_dir,
        f'chrome-{args.name}-{args.profile_directory}.desktop'.replace(
            ' ', ''))
    assert args.chrome_command is not None
    try_exec = args.chrome_command.replace(' ', r'\ ')
    with open(out_name, 'w+') as f:
        f.write(f'''#!/usr/bin/env xdg-open
[Desktop Entry]
Version=1.0
Terminal=false
Type=Application
TryExec={try_exec}
Categories={args.categories or ''}
Comment={args.comment or ''}
Name={args.name}
Exec={args.chrome_command} "--user-data-directory={args.profile_directory}"'''
                f''' "--app={args.url}"
Icon={args.icon}
''')
    log.debug('Executing update-desktop-database')
    subprocess.check_call(('update-desktop-database', apps_dir))


def _create_iconset(args: MainArgs) -> str:
    assert args.icon is not None
    iconset_dir = mkdtemp(suffix='.iconset')
    for width in (2**x for x in range(1, 11)):
        subprocess.check_call(
            ('sips', '-z', str(width), str(width), args.icon, '--out',
             path_join(iconset_dir, f'icon_{width}x{width}.png')),
            stdout=subprocess.PIPE)
        subprocess.check_call(
            ('sips', '-z', str(width), str(width), args.icon, '--out',
             path_join(iconset_dir, f'icon_{width//2}x{width//2}@2x.png')),
            stdout=subprocess.PIPE)
    return iconset_dir


def _create_app_bundle(args: MainArgs, short_name: str) -> None:
    assert args.icon is not None
    iconset_dir = _create_iconset(args)
    app_dir = expanduser(
        f'~/Applications/Chrome Apps.localized/{args.name}.app')
    contents_dir = path_join(app_dir, 'Contents')
    macos_dir = path_join(contents_dir, 'MacOS')
    res_dir = path_join(contents_dir, 'Resources')
    profile_dir_short = args.profile_directory.replace(' ', '')
    bundle_id = f'com.google.Chrome.app.{profile_dir_short}-{short_name}'
    info_plist_data = dict(
        CFBundleExecutable='app_mode_loader',
        CFBundleIconFile='app.icns',
        CFBundleIdentifier=bundle_id,
        CFBundleName=args.name,
        LSEnvironment=dict(MallocNanoZone='0'),
        NSAppleScriptEnabled=True,
        NSHighResolutionCapable=True,
    )
    for x in (contents_dir, macos_dir, res_dir):
        makedirs(x, exist_ok=True)
    subprocess.check_call(('iconutil', '-c', 'icns', iconset_dir, '-o',
                           path_join(res_dir, 'app.icns')),
                          stdout=subprocess.PIPE)
    script = path_join(macos_dir, 'app_mode_loader')
    with open(script, 'w+') as f:
        f.write('#!/usr/bin/env bash\n')
        f.write(f"open -n '{args.chrome_command}' --args "
                f"'--app={args.url}' "
                f'--user-data-directory={args.profile_directory}\n')
    chmod(script, 0o755)
    with open(path_join(contents_dir, 'Info.plist'), 'wb+') as g:
        plistlib.dump(info_plist_data, g)


def _create_shortcut(args: MainArgs) -> int:
    global log
    assert log is not None
    # Generate a JScript file and run it
    fd, script_js = mkstemp(suffix='.js')
    close(fd)
    with open(script_js, 'w+') as f:
        f.write(f'''var ows = WScript.CreateObject('WScript.Shell');
var desktop = ows.SpecialFolders('Desktop');
var link = ows.CreateShortcut(desktop + '\\\\{args.name}.lnk');
link.WorkingDirectory=desktop;\n''')
        assert args.chrome_command is not None
        if IS_MSYS and (args.chrome_command.startswith('/')
                        or args.chrome_command.startswith('./')):
            args.chrome_command = _fix_msys_arg(
                _cygpath_win(args.chrome_command))
        default_icon = f'{args.chrome_command},0'
        props = dict(
            TargetPath=args.chrome_command,
            Arguments=_fix_msys_arg(' '.join(
                map(lambda x: f'"{x}"',
                    (f'--app={args.url}',
                     f'--user-data-directory={args.profile_directory}')))),
            IconLocation=_fix_msys_arg(_cygpath_win(args.icon))
            if args.icon else default_icon,
            WindowStyle=args.window_style,
        )
        if args.comment:
            props['Description'] = args.comment
        if args.hotkey:
            props['Hotkey'] = args.hotkey
        for prop, val in props.items():
            if isinstance(val, str):
                val = f"'{val}'"
            f.write(f"link.{prop} = {val};\n")
        f.write('link.Save();\n')
    cscript_cmd = ('cscript', '//Nologo', script_js)
    log.debug('Executing %s', ' '.join(cscript_cmd))
    try:
        subprocess.check_call(cscript_cmd)
    except subprocess.CalledProcessError as e:
        log.error(f'Caught exception: {e}')
        with open(script_js, 'r') as f:
            log.info('Script:\n%s', f.read())
        return 1
    return 0


def main() -> int:
    global log
    args = _parse_args()
    log = _setup_logging_stdout(verbose=args.verbose)
    short_name: str = args.name.replace(' ', '')
    session = requests.Session()
    session.headers.update({'user-agent': USER_AGENT})
    args.icon = _get_icon_from_site(args, session)
    if not args.icon and IS_MAC:
        log.info('Need -i argument')
        return 1
    args.icon = _fetch_convert_icon(args.icon, args.name, short_name, session)
    if IS_LINUX:
        _create_desktop_file(args)
    elif IS_MAC:
        _create_app_bundle(args, short_name)
    else:
        return _create_shortcut(args)
    return 0


if __name__ == '__main__':
    sys.exit(main())
