#!/usr/bin/env python

# Based on http://www.zoneofgames.ru/forum/index.php?showtopic=27641&st=0&p=419607&#entry419607
# Copied here: https://gist.github.com/Tatsh/7623045

from os.path import realpath, getsize, basename, join as path_join
import os
import struct
import sys


def get_name(fp, offset, size):
    f.seek(offset)
    name_len = test = struct.unpack('<L', f.read(4))[0]
    test %= 4
    if test != 0:
        name_len /= 4
        name_len += 1
        name_len *= 4
    name_len = int(name_len)
    fname = struct.unpack('<%ds' % (name_len), f.read(name_len))[0]

    nbias = f.tell()
    nbias -= offset
    offset += nbias
    size -= nbias

    # Strip padding
    fname = fname.decode('ascii', errors='ignore').replace('\x00', '').replace('\x02', '')

    return (
        offset,
        size,
        fname,
    )

def get_filename(ftype, fp, offset, size):
    ext = fname = ''

    if ftype == 83:
        offset, size, fname = get_name(fp, offset, size)

        if size - 0x18 == 0:
            return (None, None)  # skip

        offset += 0x10
        f.seek(offset)
        size = struct.unpack('<L', f.read(4))[0]
        offset = f.tell()
        id_str = struct.unpack('<3s', f.read(3))[0]

        if id_str == b'RIF':
            ext = '.wav'
        elif id_str == b'Ogg':
            ext = '.ogg'
        elif id_str == b'ID3':
            ext = '.mp3'
        else:
            # Sometimes the ID3 magic is not exactly at offset + 0x10,
            #   but this check for 0xff not exactly useful either
            f.seek(offset)
            byte = struct.unpack('<s', f.read(1))[0]
            if byte == b'\xff':  # ???
                ext = '.mp3'

    return (
        '%s%s' % (fname, ext,),
        offset,
    )

if __name__ == '__main__':
    try:
        path = realpath(sys.argv[1])
    except IndexError:
        print('Unity Asset Extractor')
        print('Usage: %s FILE')
        sys.exit(1)

    filename = realpath(sys.argv[1])
    endian = '>'
    filesize = getsize(filename)

    types_not_wanted = [
        21,
        28,
        48,
        49,
        74,
    ]

    out_path = basename(sys.argv[1])
    os.makedirs('./%s' % out_path)

    with open(filename, 'rb') as f:
        f.seek(0xc)
        bias = struct.unpack('>L', f.read(4))[0]

        if bias != 0:
            f.seek(0x28)
            no_files = struct.unpack('<L', f.read(4))[0]
        else:
            f.seek(0x0)
            info_size = struct.unpack('<L', f.read(4))
            info = struct.unpack('<L', f.read(4))  # actual file size
            info -= info_size
            info += 0x15
            f.seek(info)
            no_files = struct.unpack('<L', f.read(4))[0]

        for i in range(1, no_files):
            ext = fname = wname = ''
            fid = struct.unpack('<L', f.read(4))[0]
            offset = struct.unpack('<L', f.read(4))[0]
            offset += bias
            size = struct.unpack('<L', f.read(4))[0]
            ftype = struct.unpack('<L', f.read(4))[0]
            dummy = struct.unpack('<L', f.read(4))[0]

            if ftype != 83:
                continue

            if ftype in types_not_wanted:
                continue

            last = f.tell()

            f.seek(offset)
            filename, offset = get_filename(ftype, f, offset, size)

            if filename is None:
                continue

            contents = f.read(size)

            if not len(contents):
                continue

            path = path_join('%s' % (out_path), '%d-%d-%s' % (ftype, fid, filename,))

            with open(path, 'wb') as new:
                new.write(contents)
                print('Wrote %s' % (path,))

            f.seek(last)
