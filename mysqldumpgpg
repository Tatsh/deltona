#!/usr/bin/env python
# encoding: utf-8

# clean up: find . -maxdepth 1 -type d | tail -n +2 | xargs rm -fvR *.tar *.gpg
# pip install sh python-gnupg MySQL-python

from __future__ import print_function
from datetime import datetime
from os import environ as env, remove as rm
from os.path import basename, dirname, isdir, join as path_join, realpath
from shutil import rmtree
import argparse
import re
import signal
import sys
import tarfile

from sh import bzip2, mysqldump
import gnupg
import MySQLdb as mysql

MYSQL_USER = 'tatsh'
MYSQL_HOST = 'localhost'
LOCK_WAIT_TIMEOUT = 10

DB_BLACKLIST = (
    'information_schema',
    'mysql',
    'performance_schema',
)


def rm_if_exists(fn):
    try:
        with open(fn, 'rb'):
            pass
        rm(fn)
        return True
    except IOError:
        pass

    return False


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('--target', '-t',
                        help='Target directory to store in',
                        required=True)
    parser.add_argument('--dry-run', default=False, action='store_true')
    parser.add_argument('--gpg-home', default=path_join(env['HOME'], '.gnupg'))
    parser.add_argument('--user', '-U',
                        help='MySQL user',
                        default=MYSQL_USER)
    parser.add_argument('--host', help='MySQL host', default=MYSQL_HOST)
    parser.add_argument('--verbose', '-v', action='store_true')
    parser.add_argument('gpg_recipients', metavar='GPG_RECIPIENTS', nargs='+')

    args = parser.parse_args()
    target_dir = realpath(args.target)
    time = datetime.today().strftime('%Y%m%d%H%M%S')
    dry_run = args.dry_run
    gpg_home = realpath(args.gpg_home)
    recipients = args.gpg_recipients
    user = args.user

    gpg = gnupg.GPG(gnupghome=gpg_home, verbose=args.verbose, use_agent=True)
    gpg.encoding = 'utf-8'

    m = mysql.connect(user=user,
                      db='information_schema',
                      host=args.host)
    c = m.cursor()
    c.execute('SHOW DATABASES')
    db_names = sorted([x[0] for x in c.fetchall()])

    for (i, db_name) in enumerate(db_names):
        # Cannot dump information_schema
        # No need for performance_schema
        if not db_name or \
                db_name in DB_BLACKLIST:
            continue

        fn = path_join(target_dir, '%s-%s.sql' % (time, db_name,))
        bz2_fn = '%s.bz2' % (fn,)

        print('Dumping "%s" to "%s"...' % (db_name, fn,))
        mysqldump_args = [
            '--add-drop-database',
            '--add-drop-table',
            '--comments',
            '--complete-insert',
            '--dump-date',
            '--hex-blob',
            '--max-allowed-packet=128M',
            '--order-by-primary',
            '--quick',
            '--routines',
            '--single-transaction',
            '-h', args.host,
            '-u', user,
            db_name,
        ]

        if dry_run:
            print('mysqldump %s > %s' % (' '.join(mysqldump_args), fn,))
            print('bzip2 -9 %s' % (fn,))
            print('gpg --status-fd-2 --no-tty --homedir %s --use-agent'
                  '--encrypt %s --armor --output %s.bz2.gpg' %
                  (gpg_home,
                   ' '.join(['--recipient %s' % (x) for x in recipients]),
                   fn))
            print('rm %s.tar' % (fn,))
            continue

        try:
            out = mysqldump(mysqldump_args, _out=fn).strip()
            out += bzip2(['-9', fn]).strip()
        except (KeyboardInterrupt, SystemExit):
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            print('Caught interrupt. Removing "%s"' % (fn,), file=sys.stderr)
            rm_if_exists(bz2_fn)
            rm_if_exists(fn)
            sys.exit(1)

        if len(out):
            print(out, file=sys.stderr)

        output_fn = '%s.gpg' % (bz2_fn,)
        print('Encrypting "%s" to "%s"' %
              (basename(bz2_fn), basename(output_fn),))
        with open(bz2_fn, 'rb') as fp:
            try:
                gpg.encrypt_file(fp, recipients, output=output_fn)
            except  (KeyboardInterrupt, SystemExit):
                signal.signal(signal.SIGINT, signal.SIG_IGN)
                rm_if_exists(fn)
                rm_if_exists(bz2_fn)
                rm_if_exists(output_fn)
                sys.exit(1)

        print('Removing %s' % (bz2_fn,))
        rm(bz2_fn)
