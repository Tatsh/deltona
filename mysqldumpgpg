#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
# clean up: find . -maxdepth 1 -type d | tail -n +2 | xargs rm -fvR *.tar *.gpg
# pip install python-gnupg MySQL-python
from datetime import datetime
from functools import lru_cache
from os import environ as env, remove as rm
from os.path import basename, expanduser, join as path_join, realpath
from typing import Optional, Tuple
import argparse
import logging
import signal
import subprocess as sp
import sys

from typing_extensions import Final

from pretty_bad_protocol import gnupg
import MySQLdb as mysql

try:
    import argcomplete
except ImportError:
    argcomplete = None

MYSQL_USER: Final = env['USER']
MYSQL_HOST: Final = 'localhost'
LOCK_WAIT_TIMEOUT: Final = 10
DB_BLACKLIST: Final = ('information_schema', 'mysql', 'performance_schema')


@lru_cache()
def setup_logging_stdout(name: Optional[str] = None,
                         verbose: bool = False) -> logging.Logger:
    name = name if name else basename(sys.argv[0])
    log: Final = logging.getLogger(name)
    log.setLevel(logging.DEBUG if verbose else logging.INFO)
    channel: Final = logging.StreamHandler(sys.stdout)
    channel.setFormatter(logging.Formatter('%(message)s'))
    channel.setLevel(logging.DEBUG if verbose else logging.INFO)
    log.addHandler(channel)
    return log


def mysqldump(args: Tuple[str, ...], outpath: str) -> None:
    with open(outpath, 'wb+') as f:
        sp.run(('mysqldump', ) + args, stdout=f, check=True)


def rm_if_exists(filename: str) -> bool:
    try:
        with open(filename, 'rb'):
            pass
        rm(filename)
        return True
    except FileNotFoundError:
        pass
    return False


def main() -> int:
    parser: Final = argparse.ArgumentParser()
    parser.add_argument('--target',
                        '-t',
                        help='Target directory to store in',
                        required=True)
    parser.add_argument('--dry-run', default=False, action='store_true')
    parser.add_argument('--gpg-home', default=expanduser('~/.gnupg'))
    parser.add_argument('--user', '-U', help='MySQL user', default=MYSQL_USER)
    parser.add_argument('--host', help='MySQL host', default=MYSQL_HOST)
    parser.add_argument('--verbose', '-v', action='store_true')
    parser.add_argument('--debug', '-d', action='store_true')
    parser.add_argument('gpg_recipients', metavar='GPG_RECIPIENTS', nargs='+')
    if argcomplete:
        argcomplete.autocomplete(parser)
    args: Final = parser.parse_args()
    log: Final = setup_logging_stdout(verbose=args.verbose or args.debug)
    if args.debug:
        log_ = logging.getLogger('gnupg')
        log_.setLevel(logging.DEBUG)
        channel = logging.StreamHandler(sys.stdout)
        channel.setLevel(logging.DEBUG)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s' if args.
            debug else '%(message)s')
        channel.setFormatter(formatter)
        log_.addHandler(channel)
    target_dir: Final = realpath(args.target)
    time: Final = datetime.today().strftime('%Y%m%d%H%M%S')
    dry_run: Final = args.dry_run
    gpg_home: Final = realpath(args.gpg_home)
    recipients: Final = list(args.gpg_recipients)
    user: Final = args.user

    gpg: Final = gnupg.GPG(
        homedir=gpg_home,
        verbose=args.verbose if not args.debug else 'expert',
        use_agent=True)
    keys: Final = gpg.list_keys(secret=True)
    fingerprints: Final = set()
    for k in keys:
        for uid in k['uids']:
            if recipients[0] in uid:
                fingerprints.add(k['fingerprint'])

    m: Final = mysql.connect(user=user,
                             db='information_schema',
                             host=args.host)
    c: Final = m.cursor()
    c.execute('SHOW DATABASES')
    db_names: Final = sorted(x[0] for x in c.fetchall())

    for db_name in db_names:
        if not db_name or db_name in DB_BLACKLIST:
            continue
        fn = path_join(target_dir, f'{time}-{db_name}.sql')
        log.info('Dumping "%s" to "%s"...', db_name, fn)
        mysqldump_args = ('--add-drop-database', '--add-drop-table',
                          '--comments', '--complete-insert', '--dump-date',
                          '--hex-blob', '--max-allowed-packet=128M',
                          '--order-by-primary', '--quick', '--routines',
                          '--single-transaction', '-h', args.host, '-u', user,
                          db_name)

        if dry_run:
            log.info('mysqldump %s > %s', ' '.join(mysqldump_args), fn)
            log.info(
                'gpg --status-fd-2 --no-tty --homedir %s --use-agent'
                ' --encrypt %s --armor --output %s.gpg', gpg_home,
                ' '.join('--recipient %s' % (x) for x in recipients), fn)
            log.info('rm %s.tar', fn)
            continue

        try:
            mysqldump(mysqldump_args, fn)
        except (KeyboardInterrupt, SystemExit):
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            log.warning('Caught interrupt. Removing "%s"', fn)
            rm_if_exists(fn)
            return 1
        except sp.CalledProcessError as e:
            log.error('%s failed with code %d', e.cmd, e.returncode)
            rm_if_exists(fn)
            return 1

        output_fn = f'{fn}.gpg'
        log.info('Encrypting "%s" to "%s"', basename(fn), basename(output_fn))
        with open(fn, 'rb') as fp:
            try:
                kwargs = dict(compress_algo='BZIP2', output=output_fn)
                gpg.encrypt(fp, *list(fingerprints), **kwargs)
            except (KeyboardInterrupt, SystemExit):
                signal.signal(signal.SIGINT, signal.SIG_IGN)
                rm_if_exists(fn)
                rm_if_exists(output_fn)
                return 1
            _fp = open(output_fn, 'rb')
            try:
                assert len(_fp.read()) > 0
            finally:
                _fp.close()
        log.info('Removing %s', fn)
        rm(fn)

    return 0


if __name__ == '__main__':
    sys.exit(main())
