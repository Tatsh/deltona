#!/usr/bin/env python
from os.path import basename, dirname, splitext
from tempfile import mkstemp
from typing import List, Optional, Tuple, Union
import argparse
import logging
import re
import sys

from bs4 import BeautifulSoup as Soup
from requests.exceptions import ConnectionError, InvalidSchema, InvalidURL
import requests

log: Optional[logging.Logger] = None


class FailedConnection:
    REASON_CONNECTION_ERROR = 3
    REASON_FILE_URL = 4
    REASON_INVALID_SCHEMA = 2
    REASON_INVALID_URL = 1
    REASON_UNKNOWN = 5

    def __init__(self,
                 response: requests.Response,
                 reason: int,
                 exc: Optional[Exception] = None):
        self.response = response
        self.url = response.url
        self.reason = reason
        self.exc = exc

    def strreason(self):
        if self.reason == self.REASON_INVALID_URL:
            return f'{self.url} is not a valid URL'
        if self.reason == self.REASON_FILE_URL:
            return f'{self.url} is a file URL'
        if self.reason == self.REASON_INVALID_SCHEMA:
            return f'{self.url} has an unsupported schema'
        if self.reason == self.REASON_CONNECTION_ERROR:
            return f'Connection error: {self.exc}'
        return f'Unspecified error: {self.exc}'


def setup_logging_stdout(name: Optional[str] = None,
                         verbose: bool = False) -> None:
    global log
    name = name if name else basename(sys.argv[0])
    log = logging.getLogger(name)
    log.setLevel(logging.DEBUG if verbose else logging.INFO)
    channel = logging.StreamHandler(sys.stdout)
    channel.setFormatter(logging.Formatter('%(message)s'))
    channel.setLevel(logging.DEBUG if verbose else logging.INFO)
    log.addHandler(channel)


def send(r: Optional[requests.Response]
         ) -> Optional[Union[requests.Response, FailedConnection]]:
    if not r:
        return None
    try:
        r.raise_for_status()
    except InvalidURL:
        if re.match(r'^file:///', r.url):
            return FailedConnection(r, reason=FailedConnection.REASON_FILE_URL)
        return FailedConnection(r, reason=FailedConnection.REASON_INVALID_URL)
    except InvalidSchema:
        return FailedConnection(r,
                                reason=FailedConnection.REASON_INVALID_SCHEMA)
    except ConnectionError as e:
        return FailedConnection(
            r, exc=e, reason=FailedConnection.REASON_CONNECTION_ERROR)
    except Exception as e:
        return FailedConnection(r,
                                exc=e,
                                reason=FailedConnection.REASON_UNKNOWN)
    return r


def head(session: requests.Session, uri: str) -> Optional[requests.Response]:
    assert log is not None
    try:
        return session.head(uri)
    except Exception as e:
        log.exception(e)
    return None


def recursive_scan(soup: Soup,
                   session: requests.Session,
                   last_level: int = 0,
                   size: int = 10,
                   verbose: bool = False):
    assert log is not None
    urls = []
    for a in soup.body.select('a'):
        title = ' '.join(a.contents)
        urls.append((title, a['href']))
    index = 0
    try_https: List[Tuple[str, str, int]] = []
    req: Optional[Union[requests.Response, FailedConnection]]
    for req in map(send, (head(session, u[1]) for u in urls)):
        url_data = urls[index]
        if not req:
            log.error('Failed connection: "%s" @ "%s", reason: other',
                      url_data[0], url_data[1])
            index += 1
            continue
        if isinstance(req, FailedConnection):
            log.error('Failed connection: "%s" @ "%s", reason: %s',
                      url_data[0], url_data[1], req.strreason())
            index += 1
            continue
        if req.status_code != 200:
            if req.status_code in (301, 302):
                log.info('%d: "%s" @ "%s" -> now "%s"', req.status_code,
                         url_data[0], url_data[1], req.headers['location'])
            elif req.status_code not in [401, 403]:
                log.error('%d: "%s" @ "%s"', req.status_code, url_data[0],
                          url_data[1])
            if url_data[1].startswith('https://'):
                try_https.append(
                    (url_data[0], re.sub(r'^http\://', 'https://',
                                         url_data[1]), index))
        else:
            log.debug('200: "%@" @ "%s"', url_data[1])
        index += 1
    index = 0
    for req in map(send, (head(session, u[1]) for u in urls)):
        if not req:
            index += 1
            continue
        if isinstance(req, FailedConnection):
            log.error('Failed connection: "%s" @ "%s", reason: %s',
                      url_data[0], url_data[1], req.strreason())
            index += 1
            continue
        if req.status_code != 200:
            if req.status_code not in [401, 403]:
                log.error('%d: "%s" @ "%s"', req.status_code, url_data[0],
                          url_data[1])
        else:
            log.info('Replace with HTTPS: "%s"', try_https[index][1])


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'file',
        metavar='INFILE',
        type=argparse.FileType('rb'),
        nargs=1,
        help='Bookmark HTML file (usually exported from browser)')
    parser.add_argument(
        '-o',
        '--output',
        metavar='OUTFILE',
        nargs=1,
        help=('File to output to (will be determined automatically if not '
              'specified)'))
    parser.add_argument('-q',
                        '--quiet',
                        action='store_true',
                        help='Quiet mode')
    parser.add_argument('-l',
                        '--limit',
                        type=int,
                        help='Number of concurrent requests',
                        default=2)
    args = parser.parse_args()
    output_file = args.output
    f = args.file[0]
    in_filename = f.name
    setup_logging_stdout(verbose=not args.quiet)
    assert log is not None
    if not output_file:
        output_dir = dirname(in_filename)
        output_file = 'new-' + splitext(basename(in_filename))[0]
        output_file = mkstemp(prefix=output_file,
                              dir=output_dir,
                              suffix='.html')[1]
        log.info('Writing output to "%s"', output_file)
    recursive_scan(Soup(f.read(), 'lxml'), requests.Session())
    return 0


if __name__ == '__main__':
    sys.exit(main())
