#!/usr/bin/env python
from os.path import basename
from typing import Optional, Tuple, cast
import argparse
import glob
import logging
import os
import subprocess as sp
import sys

log: Optional[logging.Logger] = None


def setup_logging_stdout(name: Optional[str] = None,
                         verbose: bool = False) -> None:
    global log
    name = name if name else basename(sys.argv[0])
    log = logging.getLogger(name)
    log.setLevel(logging.DEBUG if verbose else logging.INFO)
    channel = logging.StreamHandler(sys.stdout)
    channel.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))
    channel.setLevel(logging.DEBUG if verbose else logging.INFO)
    log.addHandler(channel)


def crc_check_with_sfv(sfv_filename: str) -> bool:
    assert log is not None
    cwd = os.getcwd()
    sfv_dir = os.path.dirname(os.path.abspath(sfv_filename))
    args = ('cksfv', '-f', sfv_filename)
    log.debug('%s', ' '.join(args))
    os.chdir(sfv_dir)
    r = sp.run(args)
    os.chdir(cwd)
    return True if r.returncode == 0 else False


def test_extraction(rar_filename: str, verbose: bool = False) -> bool:
    assert log is not None
    args = ['unrar', 't']
    if not verbose:
        args.append('-inul')
    args.append(rar_filename)
    log.debug('%s', ' '.join(args))
    r = sp.run(args)
    return True if r.returncode == 0 else False


def find_iso_in_rar(rar_filename: str) -> Tuple[Optional[str], Optional[int]]:
    # Find if there is an ISO within the RAR f
    work = ['', '']
    r = sp.run(('unrar', 'l', rar_filename), stdout=sp.PIPE, encoding='utf-8')
    for line in r.stdout.split('\n'):
        if 'iso' in line.lower():
            work = line.split()
            break
    # Handle spaces in ISO file name
    fn = work[4]
    if '.iso' not in fn.lower():
        fn = ''
        i = 0
        for iso in work[4:]:
            if '.iso' in iso.lower():
                fn += iso
                i += 1
                break
            fn += f'{iso} '
            i += 1
    if 'iso' not in fn.lower():
        return None, None
    work_str = work[4]
    if 'iso' in work_str.lower():
        i = 1
    return fn, int(work[i])


def unrar_cdrecord_pipe(rar_filename: str,
                        iso_filename: str,
                        tsize: int,
                        speed: int = 8,
                        device_name: Optional[str] = None,
                        verbose: bool = False) -> bool:
    assert log is not None
    unrar_args = (
        'unrar',
        'p',
        '-inul',
        rar_filename,
        iso_filename,
    )
    cdrecord_args = [
        'cdrecord',
        f'speed={speed}',
        'driveropts=burnfree',
        f'tsize={tsize}',
    ]
    if device_name:
        cdrecord_args.append(f'dev={device_name}')
    cdrecord_args.extend(['-dao', '-eject', '-'])
    if verbose:
        cdrecord_args.append('-v')
    log.debug('Command: %s | %s', ' '.join(unrar_args),
              ' '.join(cdrecord_args))
    r1 = sp.Popen(unrar_args, stdout=sp.PIPE, close_fds=True)
    r2 = sp.Popen(cdrecord_args, stdin=r1.stdout, close_fds=True)
    r1.stdout.close()
    r2.wait()
    r1.wait()
    return r1.returncode == 0 and r2.returncode == 0


def check_requirements(skip_crc: bool) -> bool:
    assert log is not None
    try:
        sp.check_output(('which', 'unrar'))
        if not skip_crc:
            sp.check_output(('which', 'cksfv'))
        sp.check_output(('which', 'cdrecord'))
    except sp.CalledProcessError as e:
        command_needed = e.cmd.replace('which ', '')
        log.error(f'Your system is missing "%s" (or it is not in PATH)',
                  command_needed)
        apps_to_gentoo_packages = {
            'unrar': ['app-arch/unrar', 'app-arch/unrar-gpl'],
            'cksfv': ['app-arch/cksfv'],
            'cdrecord': ['app-cdr/cdrtools'],
        }
        if len(apps_to_gentoo_packages[command_needed]) == 1:
            log.info(
                'If you are using Gentoo or a derivative with Gentoo\'s '
                'Portage tree, you can find "%s" in package %s',
                command_needed, apps_to_gentoo_packages[command_needed][0])
        else:
            packages = ', '.join(apps_to_gentoo_packages[command_needed])
            log.info(
                'If you are using Gentoo or a derivative with Gentoo\'s '
                'Portage tree, you can find "%s" in packages %s',
                command_needed, packages)
        return False
    return True


def main() -> int:
    parser = argparse.ArgumentParser(
        description='Burns an ISO found in a RAR file without extracting')
    parser.add_argument('-v',
                        help='enables verbose mode',
                        action='store_true',
                        dest='verbose')
    parser.add_argument('--no-crc-check',
                        help='Disable CRC check',
                        action='store_true',
                        dest='crc_test')
    parser.add_argument('--test-extraction',
                        help='Enable extraction test',
                        action='store_true',
                        dest='rar_test')
    parser.add_argument('-s',
                        type=int,
                        dest='speed',
                        help='Write speed',
                        default=8)
    parser.add_argument('-d',
                        dest='device',
                        default=None,
                        help='Device name (no argument means default)')
    parser.add_argument('rar_filename', help='Base RAR file name')
    args = parser.parse_args()
    rar_filename = os.path.realpath(args.rar_filename)
    setup_logging_stdout(verbose=args.verbose)
    assert log is not None
    if not check_requirements(args.crc_test):
        return 1
    iso, tsize = find_iso_in_rar(rar_filename)
    if not tsize:
        log.error(f'Unable to find ISO in RAR "%s"', args.rar_filename)
        return 1
    else:
        log.debug('Found ISO %s with tsize %d', iso, tsize)
    if not args.crc_test:
        # See if file without .rar/.001/etc exists first
        filename_without_ext, _ = os.path.splitext(args.rar_filename)
        sfv_filenames = (
            f'{filename_without_ext}.sfv',
            f'{filename_without_ext}.SFV',
        )
        sfv_filename = None
        for name in sfv_filenames:
            if os.path.exists(name):
                sfv_filename = name
                log.debug('Found SFV file: "%s"', basename(name))
        if not sfv_filename:
            globbed = glob.glob('*.sfv')
            if len(globbed):
                sfv_filename = globbed[0]
                log.debug('Found SFV file via globbing: "%s"',
                          basename(sfv_filename))
        if not sfv_filename:
            log.error('Cannot find SFV file to verify with (you can run with '
                      '--no-crc-check)')
            return 1
        if not crc_check_with_sfv(sfv_filename):
            log.error('SFV verification failed')
            return 1
    if args.rar_test:
        log.info('Testing extraction')
        if not test_extraction(rar_filename, verbose=args.verbose):
            log.error('Extraction test failed')
            return 1
        else:
            log.debug('Extraction test succeeded')
    if not unrar_cdrecord_pipe(rar_filename, cast(str, iso), tsize, args.speed,
                               args.device):
        log.error('Write failed!')
        return 1
    return 0


if __name__ == '__main__':
    sys.exit(main())
