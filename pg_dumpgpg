#!/usr/bin/env python
# encoding: utf-8

# clean up: find . -maxdepth 1 -type d | tail -n +2 | xargs rm -fvR *.tar *.gpg
# pip install sh python-gnupg

from __future__ import print_function
from datetime import datetime
from os import environ as env, remove as rm
from os.path import basename, dirname, isdir, join as path_join, realpath
from shutil import rmtree
import argparse
import re
import signal
import sys
import tarfile

from sh import psql, pg_dump, ErrorReturnCode_1
import gnupg

PG_USER = 'postgres'
PG_HOST = 'localhost'
PG_JOBS = 2
LOCK_WAIT_TIMEOUT = 10


def rm_if_exists(fn):
    try:
        with open(fn, 'rb'):
            pass
        rm(fn)
        return True
    except IOError:
        pass

    return False


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('--target',
                        '-t',
                        help='Target directory to store in',
                        required=True)
    parser.add_argument('--dry-run', default=False, action='store_true')
    parser.add_argument('--gpg-home', default=path_join(env['HOME'], '.gnupg'))
    parser.add_argument('--user',
                        '-U',
                        help='PostgreSQL user',
                        default=PG_USER)
    parser.add_argument('--host', help='PostgreSQL host', default=PG_HOST)
    parser.add_argument('--jobs',
                        '-j',
                        help='Parallel jobs',
                        default=PG_JOBS,
                        type=int)
    parser.add_argument('--verbose', '-v', action='store_true')
    parser.add_argument('gpg_recipients', metavar='GPG_RECIPIENTS', nargs='+')

    args = parser.parse_args()
    target_dir = realpath(args.target)
    time = datetime.today().strftime('%Y%m%d%H%M%S')
    dry_run = args.dry_run
    gpg_home = realpath(args.gpg_home)
    recipients = args.gpg_recipients
    user = args.user

    gpg = gnupg.GPG(gnupghome=gpg_home, verbose=args.verbose, use_agent=True)
    gpg.encoding = 'utf-8'

    psql_args = ['-X', '-w', '-U', args.user, '-h', args.host, '-l']

    for (i, db_name) in enumerate(psql(psql_args, _iter=True)):
        if i < 3:  # Skip bad lines
            continue

        name = db_name.split('|')[0].strip()
        fn = path_join(target_dir, '%s-%s' % (
            time,
            name,
        ))

        # Cannot dump template0
        # Also skip the '(x rows)' line at the end
        if not name or name == 'template0' or \
                re.match(r'^\(\d+ rows\)$', name):
            continue

        print('Dumping "%s" to "%s"...' % (
            name,
            fn,
        ))
        pg_dump_args = [
            '-w',
            '-C',
            '--column-inserts',
            '-c',
            '-U',
            args.user,
            '-h',
            args.host,
            '-d',
            name,
            '-f',
            fn,
            '-Fd',
            '-j',
            str(args.jobs),
            '-Z',
            '9',
            '--lock-wait-timeout=%d' % (LOCK_WAIT_TIMEOUT, ),
        ]

        if dry_run:
            print('pg_dump %s' % (' '.join(pg_dump_args), ))
            print('pushd %s && tar cf %s.tar %s && popd' % (
                dirname(fn),
                basename(fn),
                basename(fn),
            ))
            print('gpg --status-fd-2 --no-tty --homedir %s --use-agent'
                  '--encrypt %s --armor --output %s.tar.gpg' %
                  (gpg_home, ' '.join(
                      ['--recipient %s' % (x) for x in recipients]), fn))
            print('rm %s.tar' % (fn, ))
            continue

        try:
            out = pg_dump(pg_dump_args).strip()
        except (KeyboardInterrupt, SystemExit, ErrorReturnCode_1):
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            print('Caught interrupt. Removing "%s"' % (fn, ), file=sys.stderr)
            if isdir(fn):
                rmtree(fn)
            sys.exit(1)

        if len(out):
            print(out, file=sys.stderr)

        tar_fn = '%s.tar' % (fn, )
        print('Tar\'ing to "%s"' % (tar_fn, ))
        tar = tarfile.open(tar_fn, 'w')

        tar.add(fn, arcname=basename(fn))
        try:
            tar.close()
        except (KeyboardInterrupt, SystemExit):
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            print('Caught interrupt. Removing "%s" and data' % (tar_fn, ),
                  file=sys.stderr)
            rmtree(fn)
            try:
                with open(tar_fn, 'rb'):
                    pass
                rm(tar_fn)
            except IOError:
                pass
            sys.exit(1)

        print('Removing "%s"' % (fn, ))
        try:
            rmtree(fn)
        except (KeyboardInterrupt, SystemExit):
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            if isdir(fn):
                rmtree(fn)
            rm_if_exists(tar_fn)
            sys.exit(1)

        output_fn = '%s.gpg' % (tar_fn, )
        print('Encrypting "%s" to "%s"' % (
            basename(tar_fn),
            basename(output_fn),
        ))
        with open(tar_fn, 'rb') as fp:
            try:
                gpg.encrypt_file(fp, recipients, output=output_fn)
            except (KeyboardInterrupt, SystemExit):
                signal.signal(signal.SIGINT, signal.SIG_IGN)
                if isdir(fn):
                    rmtree(fn)
                rm_if_exists(output_fn)
                rm_if_exists(tar_fn)
                sys.exit(1)

        print('Removing "%s"' % (tar_fn, ))
        rm(tar_fn)
