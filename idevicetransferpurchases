#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function, unicode_literals
from multiprocessing import Manager, Process
from os import makedirs, remove as rm, rename
from os.path import basename, dirname, expanduser, isdir, join as path_join, realpath, splitext
from osext.filesystem import isfile
from sh import idevice_id, ideviceinfo, ideviceinstaller, unzip
import argparse
import plist
import re
import sys

verbose = False

class AppNameOrVersionError(Exception):
    pass


class AppPropertyError(Exception):
    pass


def vprint(str, stderr=False):
    global verbose

    which = sys.stdout
    if stderr:
        which = sys.stderr

    if verbose:
        print(str, file=which)


def can_unzip(filename):
    try:
        vprint('Testing unzip of %s' % (basename(filename),))
        unzip(['-t', filename])
    except:
        return False

    return True


def get_app_name(app_info):
    try:
        name = app_info['CFBundleDisplayName'].get_value().strip()

        if len(name) == 0:
            raise KeyError

        return name
    except KeyError:
        return app_info['CFBundleName'].get_value().strip()

    raise AppNameOrVersionError('get_app_name()')


def get_app_version(app_info):
    try:
        val = app_info['CFBundleShortVersionString'].get_value().strip()

        if val:
            return val
    except KeyError:
        val = app_info['CFBundleVersion'].get_value().strip()

        if val:
            return val

    raise AppNameOrVersionError('get_app_version()')


def get_device_family(app_info):
    device_families = app_info['UIDeviceFamily']
    if len(device_families) == 1:
        family = device_families[0]

        # Sometimes these values are not longs, but instead strings
        # (NSString of course)
        if isinstance(family, plist.String):
            family = int(family.get_value())

        if family == 2:
            device_family = 'ipad'
        elif family == 1:
            device_family = 'iphone'  # iPhone/iPod Touch only app
        else:
            print('What do you have plugged in? An Apple TV? Skipping this app', file=sys.stderr)
            raise AppPropertyError('get_device_family()')
    else:
        device_family = 'universal'

    return device_family


def get_output_filename(app_info):
    try:
        return '%s %s.ipa' % (get_app_name(app_info), get_app_version(app_info),)
    except UnicodeEncodeError as e:
        print('UnicodeEncodeError with name or version key (%s)' (app_info['CFBundleIdentifier'].get_value(),))
        raise e

    raise AppNameOrVersionError('get_output_filename()')


def get_ipa(target_dir, app_info, output_fn, failed_to_copy_arr):
    name = get_app_name(app_info)
    device_family = get_device_family(app_info)
    bundle_name = app_info['CFBundleIdentifier'].get_value()
    device_family_dir = path_join(target_dir, device_family)
    full_path = path_join(device_family_dir, output_fn)
    version = get_app_version(app_info)

    if verbose:
        keys = app_info.keys()
        keys.sort()

        for key in keys:
            vprint('    %s: %s' % (key, app_info[key].get_value(),))

    vprint('%s: Removing archive if it already exists' % (bundle_name,))
    ideviceinstaller(['-R', bundle_name])

    if isfile(full_path) and can_unzip(full_path):
        print('%s already exists, skipping' % (output_fn))
        return

    if not isdir(device_family_dir):
        os.mkdir(device_family_dir)

    name_version_str = 'Name: "%s", version: %s -> "%s"' % (name, version, output_fn,)
    print(name_version_str)

    current_ipa_name = path_join(target_dir, bundle_name + '.ipa')
    cmd = ['-u', udid, '-a', bundle_name, '-o', 'app_only', '-o remove', '-o', 'copy=%s' % (target_dir)]
    print('Copying')
    try:
        output = ideviceinstaller(cmd)
    except KeyboardInterrupt:
        print('Caught interrupt. Deleting %s if it exists' % (current_ipa_name,), file=sys.stderr)
        if isfile(current_ipa_name):
            rm(current_ipa_name)
            return

    vprint(output.strip())

    try:
        assert(isfile(current_ipa_name))
    except AssertionError:
        failed_to_copy_arr.append(name_version_str)
        return

    print('Verifying')
    try:
        if not can_unzip(current_ipa_name):
            print('Failed to transfer application with bundle name: %s' % (bundle_name,))
            rm(current_ipa_name)
            return
    except KeyboardInterrupt:
        print('Caught interrupt. Deleting %s if it exists' % (current_ipa_name,), file=sys.stderr)
        if isfile(current_ipa_name):
            rm(current_ipa_name)
            return

    rename(current_ipa_name, full_path)

if __name__ == '__main__':
    devices = []
    device_list = []
    parser = argparse.ArgumentParser()
    default_device = None

    for udid in idevice_id('-l', _iter=True):
        udid = udid.strip()
        name = None

        for line in ideviceinfo(['-u', udid], _iter=True):
            if re.match('^DeviceName\: ', line):
                name = line.strip()[12:]

        device_list.append((name.strip(), udid.strip(),))

        if len(device_list) == 1:
            default_device = device_list[0][0]

    parser.add_argument('-d', '--device', default=default_device, metavar='DEVICE_NAME', help='Device name (case sensitive)')
    parser.add_argument('-t', '--target', required=True)
    parser.add_argument('-v', '--verbose', action='store_true')

    args = parser.parse_args()
    verbose = args.verbose
    udid = None
    target_dir = realpath(args.target)
    failed_to_copy = []

    if not isdir(target_dir):
        print('Target directory must exist')
        sys.exit(1)

    if args.device is None:
        print('You must pick a device to use (multiple ones are plugged in or are in the configuration file)')
        for (name, udid) in devices:
            print('%s (%s)' % (name, udid,))
        sys.exit(1)

    udid = None
    for (name, u) in device_list:
        if name == args.device:
            udid = u
            break

    if not udid:
        print('Could not find UDID for %s' % (args.device,))
        sys.exit(1)

    vprint('Working with device "%s"' % (args.device,))

    full_info = plist.from_xml(ideviceinstaller(['-l', '-o', 'xml']).strip().encode('utf-8'))

    manager = Manager()
    failed_to_copy_arr = manager.list()

    for app_info in full_info:
        output_fn = get_output_filename(app_info)
        Process(target=get_ipa, args=(target_dir, app_info, output_fn, failed_to_copy_arr), name=output_fn).start()

    if len(failed_to_copy_arr):
        print('\nThe following failed to copy!')
        for line in failed_to_copy:
            print(line)
        sys.exit(1)
